#!/usr/bin/env python3

import abc
import argparse
import contextlib
import dataclasses
import json
import re
import subprocess
import sys
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, TypeVar, Union

##### Data store #####

@dataclasses.dataclass
class BranchInfo:
    name: str
    base: str
    deps: List[str]

    @classmethod
    def from_json(cls, name, o):
        return cls(name=name, **o)

    def to_json(self):
        o = dataclasses.asdict(self)
        del o['name']
        return o

@dataclasses.dataclass
class BaseBranchData:
    branches: Dict[str, BranchInfo]

    @classmethod
    def from_json(cls, o):
        branches = {
            branch: BranchInfo.from_json(branch, branch_info)
            for branch, branch_info in o['branches'].items()
        }
        return cls(branches=branches)

    def to_json(self):
        return {
            'branches': {
                branch: branch_info.to_json()
                for branch, branch_info in self.branches.items()
            },
        }

def get_data_path() -> Path:
    git_dir = git('rev-parse', '--git-common-dir')
    return Path(git_dir) / 'base-branch-info'

def load_data() -> BaseBranchData:
    data_path = get_data_path()

    if not data_path.exists():
        return BaseBranchData(branches={})

    data_text = data_path.read_text()
    return BaseBranchData.from_json(json.loads(data_text))

def save_data(data: BaseBranchData) -> None:
    data_path = get_data_path()

    data_text = json.dumps(data.to_json(), indent=2)
    data_path.write_text(data_text)

##### API #####

class UserError(Exception):
    pass

class NotOnBranchError(UserError):
    def __str__(self):
        return 'Not currently on a branch'

class MissingBranchError(UserError):
    def __init__(self, branch: str):
        self.branch = branch

    def __str__(self):
        return f'Branch `{self.branch}` does not exist'

def get_all_registered_branches(data: BaseBranchData) -> List[str]:
    return list(data.branches.keys())

def get_branch_info(
    data: BaseBranchData,
    branch: str,
    *,
    missing_ok: bool = True,
) -> Optional[BranchInfo]:
    info = data.branches.get(branch)

    if info is None and not missing_ok:
        raise UserError(f'Branch `{branch}` is not registered')

    return info

def display_branch_info(data: BaseBranchData, branch: str) -> str:
    info = get_branch_info(data, branch)

    branch_display = ''

    if info:
        branch_display += info.base

        if len(info.deps) > 0:
            num_deps = len(info.deps)
            branch_display += f' + {num_deps} '
            branch_display += 'other' if num_deps == 1 else 'others'

        commits_after_base = int(git('rev-list', '--count', '--first-parent', f'{info.base}..HEAD'))
        if commits_after_base > 0:
            branch_display += f' > [+{commits_after_base}]'

        branch_display += ' > '

    branch_display += branch

    return branch_display

def rename_branch(data: BaseBranchData, old_branch: str, new_branch: str) -> None:
    new_branch_data = {}

    for branch, info in data.branches.items():
        if branch == old_branch:
            branch = new_branch
        else:
            info = BranchInfo(
                base=info.base if info.base != old_branch else new_branch,
                deps=[
                    dep if dep != old_branch else new_branch
                    for dep in info.deps
                ],
            )

        new_branch_data[branch] = info

    data.branches = new_branch_data

def set_base_branch(data: BaseBranchData, branch: str, base_branch: str) -> None:
    info = get_branch_info(data, branch)
    if info is None:
        info = BranchInfo(base=base_branch, deps=[])
    else:
        info.base = base_branch

    data.branches[branch] = info

def add_dep_branch(data: BaseBranchData, branch: str, dep_branch: str) -> None:
    info = get_branch_info(data, branch, missing_ok=False)
    if dep_branch in info.deps:
        raise UserError(f'Could not add branch dependency: `{dep_branch}` is already a dependency')
    if dep_branch == info.base:
        raise UserError(f'Could not add branch dependency: `{dep_branch}` is the base branch')
    info.deps.append(dep_branch)

def rm_dep_branch(data: BaseBranchData, branch: str, dep_branch: str) -> None:
    info = get_branch_info(data, branch)
    if info and dep_branch in info.deps:
        info.deps.remove(dep_branch)

def delete_branch(data: BaseBranchData, branch: str) -> None:
    data.branches.pop(branch, None)
    for branch_info in data.branches.values():
        if branch in branch_info.deps:
            branch_info.deps.remove(branch)

##### Git helpers #####

def get_current_branch() -> str:
    branch = git('branch', '--show-current')
    if len(branch) == 0:
        raise NotOnBranchError()
    return branch

def branch_exists(branch: str) -> bool:
    try:
        git('show-ref', branch)
    except subprocess.CalledProcessError:
        return False
    else:
        return True

def resolve_branch(branch: Optional[str]) -> str:
    if branch is None:
        branch = get_current_branch()

    if not branch_exists(branch):
        raise MissingBranchError(branch)

    return branch

def get_default_base_branch() -> str:
    if branch_exists('main'):
        return 'main'

    if branch_exists('master'):
        return 'master'

    remote_info = git('remote', 'show', 'origin')
    return re.search('HEAD branch: (.*)$', remote_info, flags=re.M).group(1)

def git(*args) -> str:
    return subprocess.check_output(['git'] + list(args)).decode().strip()

##### CLI Commands #####

class CLICommand(abc.ABC):
    @abc.abstractmethod
    def run(self, data: BaseBranchData):
        pass

class CLIBranchCommand(CLICommand):
    def __init__(self, *, branch: Optional[str]):
        self._branch = branch

    @property
    def branch(self) -> str:
        return resolve_branch(self._branch)

class CLICommandListAll(CLICommand):
    def __init__(self, *, as_json: bool = False):
        super().__init__()
        self._as_json = as_json

    def run(self, data: BaseBranchData):
        print_branch_info(data, get_all_registered_branches(data), as_json=self._as_json)

class CLICommandGetBase(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        with contextlib.suppress(NotOnBranchError):
            info = get_branch_info(data, self.branch)
            if info:
                print(info.base)

class CLICommandGetDeps(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        with contextlib.suppress(NotOnBranchError):
            info = get_branch_info(data, self.branch)
            if info:
                for dep in info.deps:
                    print(dep)

class CLICommandGetDefaultBaseBranch(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        print(get_default_base_branch())

class CLICommandDisplay(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        with contextlib.suppress(NotOnBranchError):
            branch_display = display_branch_info(data, self.branch)
            print(branch_display)

class CLICommandRenameTo(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], new_branch: str):
        super().__init__(branch=branch)
        self._new_branch = new_branch

    def run(self, data: BaseBranchData):
        # allow renaming branches that don't exist anymore
        try:
            branch = self.branch
        except MissingBranchError as e:
            branch = e.branch

        rename_branch(data, branch, self._new_branch)
        save_data(data)
        print(f'Renamed branch `{branch}` to `{self._new_branch}`')

class CLICommandSetBase(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], base: str):
        super().__init__(branch=branch)
        self._base = base

    def run(self, data: BaseBranchData):
        base_branch = resolve_branch(self._base)

        set_base_branch(data, self.branch, base_branch)
        save_data(data)
        print(f'Set `{base_branch}` as base branch for `{self.branch}`')

class CLICommandAddDep(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], deps: str):
        super().__init__(branch=branch)
        self._deps = deps

    def run(self, data: BaseBranchData):
        for dep in self._deps:
            dep = resolve_branch(dep)
            add_dep_branch(data, self.branch, dep)

        save_data(data)
        print(f'Added branch dependencies for `{self.branch}`: ' + ', '.join(self._deps))

class CLICommandRemoveDep(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], deps: str):
        super().__init__(branch=branch)
        self._deps = deps

    def run(self, data: BaseBranchData):
        for dep in self._deps:
            rm_dep_branch(data, self.branch, dep)

        save_data(data)
        print(f'Removed branch dependencies for `{self.branch}`: ' + ', '.join(self._deps))

class CLICommandClear(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        # allow clearing branches that don't exist anymore
        try:
            branch = self.branch
        except MissingBranchError as e:
            branch = e.branch

        delete_branch(data, branch)
        save_data(data)
        print(f'Deleted branch `{branch}` from base-branch database')

class CLICommandShowBranch(CLIBranchCommand):
    def __init__(self, *, branch: str, as_json: bool = False):
        super().__init__(branch=branch)
        self._as_json = as_json

    def run(self, data: BaseBranchData):
        print_branch_info(data, [self.branch], as_json=self._as_json)

def print_branch_info(
    data: BaseBranchData,
    branches: List[str],
    *,
    as_json: bool = False,
) -> None:
    infos = [
        get_branch_info(data, branch, missing_ok=False)
        for branch in branches
    ]

    if as_json:
        o = [
            {
                "branch": info.name,
                "base": info.base,
                "deps": info.deps,
            }
            for info in infos
        ]
        print(json.dumps(o))
    else:
        branch_outputs = []
        for info in infos:
            deps = ', '.join(info.deps)
            branch_outputs.append(
                '\n'.join([
                    info.name,
                    f' ├─ base = {info.base}',
                    f' └─ deps = [{deps}]',
                ])
            )
        print('\n\n'.join(branch_outputs))

##### Argument parsing #####

def parse_args() -> CLICommand:
    parser = argparse.ArgumentParser()

    parser.add_argument('branch', nargs='?')
    parser.add_argument('--json', action='store_true')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--list', '-l', action='store_true', default=None)
    group.add_argument('--base', action='store_true', default=None)
    group.add_argument('--deps', action='store_true', default=None)
    group.add_argument('--default-base-branch', action='store_true', default=None)
    group.add_argument('--display', action='store_true', default=None)
    group.add_argument('--rename-to')
    group.add_argument('--set-base')
    group.add_argument('--add-dep', metavar='DEP', nargs='+')
    group.add_argument('--rm-dep', metavar='DEP', nargs='+')
    group.add_argument('--clear', action='store_true', default=None)

    args = parser.parse_args()

    if args.list:
        if args.branch is not None:
            raise parser.error('`--list` or `-l` cannot be specified with any other arguments')

        return CLICommandListAll(as_json=args.json)

    if args.base:
        return CLICommandGetBase(branch=args.branch)

    if args.deps:
        return CLICommandGetDeps(branch=args.branch)

    if args.default_base_branch:
        return CLICommandGetDefaultBaseBranch(branch=args.branch)

    if args.display:
        return CLICommandDisplay(branch=args.branch)

    if args.rename_to:
        return CLICommandRenameTo(branch=args.branch, new_branch=args.rename_to)

    if args.set_base:
        return CLICommandSetBase(branch=args.branch, base=args.set_base)

    if args.add_dep:
        return CLICommandAddDep(branch=args.branch, deps=args.add_dep)

    if args.rm_dep:
        return CLICommandRemoveDep(branch=args.branch, deps=args.rm_dep)

    if args.clear:
        return CLICommandClear(branch=args.branch)

    return CLICommandShowBranch(branch=args.branch, as_json=args.json)

##### Entrypoint #####

def main() -> None:
    command = parse_args()
    data = load_data()
    command.run(data)

if __name__ == '__main__':
    try:
        main()
    except UserError as e:
        print(f'(git-bb) ERROR: {e}', file=sys.stderr)
        sys.exit(1)
