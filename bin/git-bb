#!/usr/bin/env python3

import abc
import argparse
import contextlib
import dataclasses
import sys
from pathlib import Path

HERE = Path(__file__).resolve().parent
sys.path.insert(0, (HERE.parent / 'git-bb').as_posix())

from git_bb.api import *
from git_bb.git import *
from git_bb.store import *
from git_bb.utils import abort

def main() -> None:
    command = parse_args()
    data = load_data()
    try:
        command.run(data)
    except APIError as e:
        abort(str(e), prefix='git-bb')

def parse_args() -> "CLICommand":
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    def _mk_one_branch_command(subparser, f):
        subparser.add_argument('branch', nargs='?')
        subparser.set_defaults(mk_command=lambda args: f(args.branch))

    def _mk_two_branch_command(subparser, f):
        subparser.add_argument('branches', metavar='BRANCH', nargs='+')
        def _mk_command(args):
            branches = args.branches
            if len(branches) == 1:
                target_branch = None
                arg_branch, = branches
            elif len(branches) == 2:
                target_branch, arg_branch = branches
            else:
                raise subparser.error(f'Must specify exactly 1 or 2 branches')
            return f(target_branch, arg_branch)
        subparser.set_defaults(mk_command=_mk_command)

    def _mk_multi_branch_command(subparser, f):
        subparser.add_argument('branches', metavar='BRANCH', nargs='+')
        subparser.add_argument('--target')
        subparser.set_defaults(mk_command=lambda args: f(args.target, args.branches))

    parser_list = subparsers.add_parser('list')
    parser_list.add_argument('--json', action='store_true')
    parser_list.set_defaults(mk_command=lambda args: CLICommandListAll(as_json=args.json))

    parser_show = subparsers.add_parser('show')
    parser_show.add_argument('branch', nargs='?')
    parser_show.add_argument('--json', action='store_true')
    parser_show.set_defaults(mk_command=lambda args: CLICommandShowBranch(branch=args.branch, as_json=args.json))

    parser_get_base = subparsers.add_parser('get-base')
    _mk_one_branch_command(parser_get_base, lambda branch: CLICommandGetBase(branch=branch))

    parser_get_deps = subparsers.add_parser('get-deps')
    _mk_one_branch_command(parser_get_deps, lambda branch: CLICommandGetDeps(branch=branch))

    parser_display = subparsers.add_parser('display')
    _mk_one_branch_command(parser_display, lambda branch: CLICommandDisplay(branch=branch))

    parser_rename = subparsers.add_parser('rename')
    _mk_two_branch_command(parser_rename, lambda old, new: CLICommandRenameTo(branch=old, new_branch=new))

    parser_set_base = subparsers.add_parser('set-base')
    _mk_two_branch_command(parser_set_base, lambda target, base: CLICommandSetBase(branch=target, base=base))

    parser_add_deps = subparsers.add_parser('add-deps', aliases=['add-dep'])
    _mk_multi_branch_command(parser_add_deps, lambda branch, deps: CLICommandAddDeps(branch=branch, deps=deps))

    parser_rm_deps = subparsers.add_parser('rm-deps', aliases=['rm-dep'])
    _mk_multi_branch_command(parser_rm_deps, lambda branch, deps: CLICommandRemoveDeps(branch=branch, deps=deps))

    parser_clear = subparsers.add_parser('clear')
    _mk_one_branch_command(parser_clear, lambda branch: CLICommandClear(branch=branch))

    parser.set_defaults(mk_command=lambda args: CLICommandShowBranch())

    args = parser.parse_args()
    return args.mk_command(args)

##### CLI Commands #####

class CLICommand(abc.ABC):
    @abc.abstractmethod
    def run(self, data: BaseBranchData):
        pass

@dataclasses.dataclass(kw_only=True)
class CLIBranchCommand(CLICommand):
    branch: str | None = None

    @property
    def resolved_branch(self) -> str:
        return resolve_branch(self.branch)

@dataclasses.dataclass(kw_only=True)
class CLICommandListAll(CLICommand):
    as_json: bool = False

    def run(self, data: BaseBranchData):
        print_branch_info(data, get_all_registered_branches(data), as_json=self.as_json)

class CLICommandGetBase(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        with contextlib.suppress(NotOnBranchError):
            info = get_branch_info(data, self.resolved_branch)
            if info:
                print(info.base)

class CLICommandGetDeps(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        with contextlib.suppress(NotOnBranchError):
            info = get_branch_info(data, self.resolved_branch)
            if info:
                for dep in info.deps:
                    print(dep)

class CLICommandDisplay(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        with contextlib.suppress(NotOnBranchError):
            branch_display = display_branch_info(data, self.resolved_branch)
            print(branch_display)

@dataclasses.dataclass(kw_only=True)
class CLICommandRenameTo(CLIBranchCommand):
    new_branch: str

    def run(self, data: BaseBranchData):
        # allow renaming branches that don't exist anymore
        try:
            branch = self.resolved_branch
        except MissingBranchError as e:
            branch = e.branch

        rename_branch(data, branch, self._new_branch)
        save_data(data)
        print(f'Renamed branch `{branch}` to `{self._new_branch}`')

@dataclasses.dataclass(kw_only=True)
class CLICommandSetBase(CLIBranchCommand):
    base: str

    def run(self, data: BaseBranchData):
        base_branch = resolve_branch(self._base)
        set_base_branch(data, self.resolved_branch, base_branch=base_branch)
        save_data(data)
        print(f'Set `{base_branch}` as base branch for `{self.resolved_branch}`')

@dataclasses.dataclass(kw_only=True)
class CLICommandAddDeps(CLIBranchCommand):
    deps: list[str]

    def run(self, data: BaseBranchData):
        add_dep_branches(data, self.resolved_branch, [resolve_branch(dep) for dep in self._deps])
        save_data(data)
        print(f'Added branch dependencies for `{self.resolved_branch}`: ' + ', '.join(self._deps))

@dataclasses.dataclass(kw_only=True)
class CLICommandRemoveDeps(CLIBranchCommand):
    deps: list[str]

    def run(self, data: BaseBranchData):
        rm_dep_branches(data, self.resolved_branch, self._deps)
        save_data(data)
        print(f'Removed branch dependencies for `{self.resolved_branch}`: ' + ', '.join(self._deps))

class CLICommandClear(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        # allow clearing branches that don't exist anymore
        try:
            branch = self.resolved_branch
        except MissingBranchError as e:
            branch = e.branch

        delete_branch(data, branch)
        save_data(data)
        print(f'Deleted branch `{branch}` from base-branch database')

@dataclasses.dataclass(kw_only=True)
class CLICommandShowBranch(CLIBranchCommand):
    as_json: bool = False

    def run(self, data: BaseBranchData):
        print_branch_info(data, [self.resolved_branch], as_json=self.as_json)

def print_branch_info(
    data: BaseBranchData,
    branches: List[str],
    *,
    as_json: bool = False,
) -> None:
    infos = [
        get_branch_info(data, branch, missing_ok=False)
        for branch in branches
    ]

    if as_json:
        o = [
            {
                "branch": info.name,
                "base": info.base,
                "deps": info.deps,
            }
            for info in infos
        ]
        print(json.dumps(o))
    else:
        branch_outputs = []
        for info in infos:
            deps = ', '.join(info.deps)
            branch_outputs.append(
                '\n'.join([
                    info.name,
                    f' ├─ base = {info.base}',
                    f' └─ deps = [{deps}]',
                ])
            )
        print('\n\n'.join(branch_outputs))

##### Entrypoint #####

if __name__ == '__main__':
    main()
