#!/usr/bin/env python3

import abc
import argparse
import dataclasses
import json
import re
import subprocess
import sys
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, TypeVar, Union

##### Data store #####

@dataclasses.dataclass
class BranchInfo:
    base: str
    deps: List[str]

    @classmethod
    def from_json(cls, o):
        return cls(**o)

    def to_json(self):
        return dataclasses.asdict(self)

@dataclasses.dataclass
class BaseBranchData:
    branches: Dict[str, BranchInfo]

    @classmethod
    def from_json(cls, o):
        branches = {
            branch: BranchInfo.from_json(branch_info)
            for branch, branch_info in o['branches'].items()
        }
        return cls(branches=branches)

    def to_json(self):
        return {
            'branches': {
                branch: branch_info.to_json()
                for branch, branch_info in self.branches.items()
            },
        }

def get_data_path() -> Path:
    git_dir = git('rev-parse', '--git-common-dir')
    return Path(git_dir) / 'base-branch-info'

def load_data() -> BaseBranchData:
    data_path = get_data_path()

    if not data_path.exists():
        return BaseBranchData(branches={})

    data_text = data_path.read_text()
    return BaseBranchData.from_json(json.loads(data_text))

def save_data(data: BaseBranchData) -> None:
    data_path = get_data_path()

    data_text = json.dumps(data.to_json(), indent=2)
    data_path.write_text(data_text)

##### API #####

class UserError(Exception):
    pass

class NotOnBranchError(UserError):
    def __str__(self):
        return 'Not currently on a branch'

class MissingBranchError(UserError):
    def __init__(self, branch: str):
        self.branch = branch

    def __str__(self):
        return f'Branch `{self.branch}` does not exist'

def get_all_registered_branches(data: BaseBranchData) -> List[str]:
    return list(data.branches.keys())

def get_branch_info(data: BaseBranchData, branch: str) -> Optional[BranchInfo]:
    return data.branches.get(branch)

def display_branch_info(data: BaseBranchData, branch: str) -> str:
    info = get_branch_info(data, branch)

    branch_display = ''

    if info:
        branch_display += info.base

        if len(info.deps) > 0:
            num_deps = len(info.deps)
            branch_display += f' + {num_deps} '
            branch_display += 'other' if num_deps == 1 else 'others'

        commits_after_base = int(git('rev-list', '--count', '--first-parent', f'{info.base}..HEAD'))
        if commits_after_base > 0:
            branch_display += f' > [+{commits_after_base}]'

        branch_display += ' > '

    branch_display += branch

    return branch_display

def rename_branch(data: BaseBranchData, old_branch: str, new_branch: str) -> None:
    new_branch_data = {}

    for branch, info in data.branches.items():
        if branch == old_branch:
            branch = new_branch
        else:
            info = BranchInfo(
                base=info.base if info.base != old_branch else new_branch,
                deps=[
                    dep if dep != old_branch else new_branch
                    for dep in info.deps
                ],
            )

        new_branch_data[branch] = info

    data.branches = new_branch_data

def set_base_branch(data: BaseBranchData, branch: str, base_branch: str) -> None:
    info = get_branch_info(data, branch)
    if info is None:
        info = BranchInfo(base=base_branch, deps=[])
    else:
        info.base = base_branch

    data.branches[branch] = info

def add_dep_branch(data: BaseBranchData, branch: str, dep_branch: str) -> None:
    info = get_branch_info(data, branch)
    if info is None:
        raise UserError(f'Could not add branch dependency: `{branch}` is not a registered branch')
    if dep_branch in info.deps:
        raise UserError(f'Could not add branch dependency: `{branch}` is already a dependency')
    if dep_branch == info.base:
        raise UserError(f'Could not add branch dependency: `{branch}` is the base branch')
    info.deps.append(dep_branch)

def rm_dep_branch(data: BaseBranchData, branch: str, dep_branch: str) -> None:
    info = get_branch_info(data, branch)
    if info and dep_branch in info.deps:
        info.deps.remove(dep_branch)

def delete_branch(data: BaseBranchData, branch: str) -> None:
    data.branches.pop(branch, None)
    for branch_info in data.branches.values():
        if branch in branch_info.deps:
            branch_info.deps.remove(branch)

##### Git helpers #####

def get_current_branch() -> str:
    branch = git('branch', '--show-current')
    if len(branch) == 0:
        raise NotOnBranchError()
    return branch

def branch_exists(branch: str) -> bool:
    try:
        git('show-ref', branch)
    except subprocess.CalledProcessError:
        return False
    else:
        return True

def get_default_base_branch() -> str:
    if branch_exists('main'):
        return 'main'

    if branch_exists('master'):
        return 'master'

    remote_info = git('remote', 'show', 'origin')
    return re.search('HEAD branch: (.*)$', remote_info, flags=re.M).group(1)

def git(*args) -> str:
    return subprocess.check_output(['git'] + list(args)).decode().strip()

##### CLI Commands #####

class CLICommand(abc.ABC):
    @abc.abstractmethod
    def run(self, data: BaseBranchData):
        pass

class CLIBranchCommand(CLICommand):
    def __init__(self, *, branch: Optional[str]):
        self._branch = branch

    @property
    def branch(self) -> str:
        branch = self._branch

        if branch is None:
            branch = get_current_branch()

        if not branch_exists(branch):
            raise MissingBranchError(branch)

        return branch

class CLICommandListAll(CLICommand):
    def run(self, data: BaseBranchData):
        for branch in get_all_registered_branches(data):
            print_branch_info(data, branch)
            print()

class CLICommandGetBase(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        try:
            info = get_branch_info(data, self.branch)
            if info:
                print(info.base)
        except NotOnBranchError:
            pass

class CLICommandGetDeps(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        try:
            info = get_branch_info(data, self.branch)
            for dep in info.deps:
                print(dep)
        except NotOnBranchError:
            pass

class CLICommandGetDefaultBaseBranch(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        print(get_default_base_branch())

class CLICommandDisplay(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        try:
            branch_display = display_branch_info(data, self.branch)
            print(branch_display)
        except NotOnBranchError:
            pass

class CLICommandRenameTo(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], new_branch: str):
        super().__init__(branch=branch)
        self._new_branch = new_branch

    def run(self, data: BaseBranchData):
        # allow renaming branches that don't exist anymore
        try:
            branch = self.branch
        except MissingBranchError as e:
            branch = e.branch

        rename_branch(data, branch, self._new_branch)
        save_data(data)
        print(f'Renamed branch `{branch}` to `{self._new_branch}`')

class CLICommandSetBase(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], base: str):
        super().__init__(branch=branch)
        self._base = base

    def run(self, data: BaseBranchData):
        if not branch_exists(self._base):
            raise MissingBranchError(self._base)

        set_base_branch(data, self.branch, self._base)
        save_data(data)
        print(f'Set `{self._base}` as base branch for `{self.branch}`')

class CLICommandAddDep(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], dep: str):
        super().__init__(branch=branch)
        self._dep = dep

    def run(self, data: BaseBranchData):
        if not branch_exists(self._dep):
            raise MissingBranchError(self._dep)

        add_dep_branch(data, self.branch, self._dep)
        save_data(data)
        print(f'Added `{self._dep}` as a branch dependency for `{self.branch}`')

class CLICommandRemoveDep(CLIBranchCommand):
    def __init__(self, *, branch: Optional[str], dep: str):
        super().__init__(branch=branch)
        self._dep = dep

    def run(self, data: BaseBranchData):
        rm_dep_branch(data, self.branch, self._dep)
        save_data(data)
        print(f'Removed `{self._dep}` as a branch dependency for `{self.branch}`')

class CLICommandClear(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        # allow clearing branches that don't exist anymore
        try:
            branch = self.branch
        except MissingBranchError as e:
            branch = e.branch

        delete_branch(data, branch)
        save_data(data)
        print(f'Deleted branch `{branch}` from base-branch database')

class CLICommandShowCurrent(CLIBranchCommand):
    def run(self, data: BaseBranchData):
        print_branch_info(data, self.branch)

def print_branch_info(data: 'BaseBranchData', branch: str) -> None:
    info = get_branch_info(data, branch)

    if info is None:
        raise UserError(f'Branch `{branch}` is not registered.')

    deps = ', '.join(info.deps)
    print('\n'.join([
        branch,
        f' ├─ base = {info.base}',
        f' └─ deps = [{deps}]',
    ]))

##### Argument parsing #####

def parse_args() -> CLICommand:
    parser = argparse.ArgumentParser()

    parser.add_argument('branch', nargs='?')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--list', '-l', action='store_true', default=None)
    group.add_argument('--base', action='store_true', default=None)
    group.add_argument('--deps', action='store_true', default=None)
    group.add_argument('--default-base-branch', action='store_true', default=None)
    group.add_argument('--display', action='store_true', default=None)
    group.add_argument('--rename-to')
    group.add_argument('--set-base')
    group.add_argument('--add-dep')
    group.add_argument('--rm-dep')
    group.add_argument('--clear', action='store_true', default=None)

    args = parser.parse_args()

    if args.list:
        if args.branch is not None:
            raise parser.error('`--list` or `-l` cannot be specified with any other arguments')

        return CLICommandListAll()

    if args.base:
        return CLICommandGetBase(branch=args.branch)

    if args.deps:
        return CLICommandGetDeps(branch=args.branch)

    if args.default_base_branch:
        return CLICommandGetDefaultBaseBranch(branch=args.branch)

    if args.display:
        return CLICommandDisplay(branch=args.branch)

    if args.rename_to:
        return CLICommandRenameTo(branch=args.branch, new_branch=args.rename_to)

    if args.set_base:
        return CLICommandSetBase(branch=args.branch, base=args.set_base)

    if args.add_dep:
        return CLICommandAddDep(branch=args.branch, dep=args.add_dep)

    if args.rm_dep:
        return CLICommandRemoveDep(branch=args.branch, dep=args.rm_dep)

    if args.clear:
        return CLICommandClear(branch=args.branch)

    return CLICommandShowCurrent(branch=args.branch)

##### Entrypoint #####

def main() -> None:
    command = parse_args()
    data = load_data()
    command.run(data)

if __name__ == '__main__':
    try:
        main()
    except UserError as e:
        print(f'(git-bb) ERROR: {e}', file=sys.stderr)
        sys.exit(1)
